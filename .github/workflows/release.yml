# Publish release and upload Tauri build artifacts for multiple platforms
name: 'publish'

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-22.04
    outputs:
      release_id: ${{ steps.create_release.outputs.release_id }}
      release_tag: ${{ steps.create_release.outputs.release_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Create GitHub release (draft) and output release id
        id: create_release
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            // Get the tag name robustly
            const envRef = process.env.GITHUB_REF || '';
            const refName = process.env.GITHUB_REF_NAME || (envRef.replace(/^refs\/(tags|heads)\//, '') || '');

            if (!refName) {
              core.setFailed('Tag name not available in GITHUB_REF / GITHUB_REF_NAME; cannot create release.');
              return;
            }

            // Create the release (draft)
            const createRes = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: refName,
              name: `App ${refName}`,
              body: 'See the assets to download this version and install.',
              draft: true,
              prerelease: false
            });

            const releaseId = createRes.data.id;
            core.info(`Created release id=${releaseId} tag=${createRes.data.tag_name}`);

            // Export step outputs (write to GITHUB_OUTPUT)
            const fs = require('fs');
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `release_id=${releaseId}\n`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `release_tag=${refName}\n`);

  publish-tauri:
    needs: create-release
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
          - platform: 'ubuntu-22.04'
            args: ''
          - platform: 'windows-latest'
            args: ''
          - platform: 'windows-latest'
            args: '--target aarch64-pc-windows-msvc'

    runs-on: ${{ matrix.platform }}
    env:
      RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
      RELEASE_TAG: ${{ needs.create-release.outputs.release_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Rust target for Windows ARM64
        if: matrix.args == '--target aarch64-pc-windows-msvc'
        run: rustup target add aarch64-pc-windows-msvc

      - name: install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf jq

      - name: setup node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'

      - name: install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: install frontend dependencies
        run: npm install

      - name: Build Tauri app
        run: |
          echo "Building on ${{ matrix.platform }} with args '${{ matrix.args }}'"
          npm run tauri build -- ${{ matrix.args }}

      - name: Find and upload build artifacts to release (uses RELEASE_ID if available)
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_ID: ${{ env.RELEASE_ID }}
          RELEASE_TAG: ${{ env.RELEASE_TAG }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            // Note: github-script injects `core`, `github`, and `context`

            function walk(dir) {
              let results = [];
              const list = fs.readdirSync(dir || '.');
              list.forEach(function(file) {
                file = path.join(dir, file);
                const stat = fs.statSync(file);
                if (stat && stat.isDirectory()) {
                  results = results.concat(walk(file));
                } else {
                  results.push(file);
                }
              });
              return results;
            }

            const repoRoot = process.cwd();
            const exts = ['.AppImage', '.dmg', '.deb', '.rpm', '.msi', '.exe', '.zip', '.tar.gz', '.tgz', '.pkg'];

            const searchDirs = [
              path.join('src-tauri','target','release','bundle'),
              path.join('src-tauri','target','release','bundle','osx'),
              path.join('src-tauri','target','release','bundle','debian'),
              path.join('src-tauri','target','release','bundle','linux'),
              path.join('src-tauri','target','release','bundle','msi'),
              path.join('dist'),
              path.join('release')
            ];

            let candidates = [];
            for (const d of searchDirs) {
              const full = path.join(repoRoot, d);
              if (fs.existsSync(full)) {
                candidates = candidates.concat(walk(full));
              }
            }
            if (candidates.length === 0) {
              core.info('No artifacts found in expected locations; scanning repo root as fallback (may be slow).');
              candidates = candidates.concat(walk(repoRoot));
            }

            const uniq = Array.from(new Set(candidates));
            const artifacts = uniq.filter(f => {
              const lower = f.toLowerCase();
              for (const e of exts) if (lower.endsWith(e.toLowerCase())) return true;
              try { return fs.statSync(f).size > 1024 && path.basename(f).toLowerCase().includes('refforge'); } catch(e) { return false; }
            });

            if (artifacts.length === 0) {
              core.info('No release artifacts found to upload. Listing candidates for debugging:');
              core.info(JSON.stringify(uniq.slice(0,50), null, 2));
              return;
            }

            // Use the RELEASE_ID passed from create-release if available
            let releaseId = process.env.RELEASE_ID || '';
            let releaseData = null;

            if (releaseId) {
              try {
                const r = await github.rest.repos.getRelease({ owner: context.repo.owner, repo: context.repo.repo, release_id: Number(releaseId) });
                releaseData = r.data;
              } catch (e) {
                core.info(`getRelease(release_id=${releaseId}) failed: ${e.message}`);
                releaseData = null;
              }
            }

            // Fallback: if we don't have releaseData, try to find by tag (only if tag present) or by name/draft
            const envRef = process.env.GITHUB_REF || '';
            const refName = process.env.GITHUB_REF_NAME || (envRef.replace(/^refs\/(tags|heads)\//, '') || '');
            const isTag = envRef.startsWith('refs/tags/');

            if (!releaseData && isTag && refName) {
              try {
                const res = await github.rest.repos.getReleaseByTag({ owner: context.repo.owner, repo: context.repo.repo, tag: refName });
                releaseData = res.data;
              } catch (e) {
                core.info(`getReleaseByTag(${refName}) failed: ${e.message}`);
              }
            }

            if (!releaseData) {
              // try to find the draft release created earlier with name "App <tag>"
              const expectedName = `App ${process.env.RELEASE_TAG || refName}`;
              core.info(`Searching for draft release with name="${expectedName}"`);
              const list = await github.rest.repos.listReleases({ owner: context.repo.owner, repo: context.repo.repo, per_page: 100 });
              releaseData = list.data.find(r => r.name === expectedName && r.draft === true);
            }

            if (!releaseData) {
              core.setFailed('Could not find a draft release to upload assets to. Ensure create-release created the draft release and that the workflow was triggered on a tag.');
              return;
            }

            const finalReleaseId = releaseData.id;

            for (const filePath of artifacts) {
              const name = path.basename(filePath);
              core.info(`Uploading ${filePath} as ${name} to release id=${finalReleaseId}`);
              const data = fs.readFileSync(filePath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: finalReleaseId,
                name: name,
                data: data,
                headers: {
                  'content-type': 'application/octet-stream',
                  'content-length': data.length
                }
              });
            }

  publish-release:
    needs: publish-tauri
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    steps:
      - name: Publish GitHub release (clear draft)
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          RELEASE_TAG: ${{ needs.create-release.outputs.release_tag }}
        with:
          script: |
            // Note: github-script injects `core`, `github`, and `context`
            let releaseData = null;
            if (process.env.RELEASE_ID) {
              try {
                const r = await github.rest.repos.getRelease({ owner: context.repo.owner, repo: context.repo.repo, release_id: Number(process.env.RELEASE_ID) });
                releaseData = r.data;
              } catch (e) {
                core.info(`getRelease(release_id=${process.env.RELEASE_ID}) failed: ${e.message}`);
              }
            }

            if (!releaseData) {
              const envRef = process.env.GITHUB_REF || '';
              const refName = process.env.RELEASE_TAG || process.env.GITHUB_REF_NAME || (envRef.replace(/^refs\/(tags|heads)\//, '') || '');
              if (envRef.startsWith('refs/tags/') && refName) {
                try {
                  const res = await github.rest.repos.getReleaseByTag({ owner: context.repo.owner, repo: context.repo.repo, tag: refName });
                  releaseData = res.data;
                } catch (e) {
                  core.info(`getReleaseByTag(${refName}) failed: ${e.message}`);
                }
              }
            }

            if (!releaseData) {
              const expectedName = `App ${process.env.RELEASE_TAG || process.env.GITHUB_REF_NAME || ''}`;
              const list = await github.rest.repos.listReleases({ owner: context.repo.owner, repo: context.repo.repo, per_page: 100 });
              releaseData = list.data.find(r => r.name === expectedName && r.draft === true);
            }

            if (!releaseData) {
              core.setFailed('Could not find the draft release to publish. Ensure the draft release exists and assets were uploaded.');
              return;
            }

            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseData.id,
              draft: false
            });
            core.info(`Published release ${releaseData.tag_name || releaseData.name}`);