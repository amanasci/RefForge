# Publish release and upload Tauri build artifacts for multiple platforms
name: 'publish'

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'

# Give the jobs write access to repo contents (needed to create/update/releases and upload assets)
permissions:
  contents: write

jobs:
  # Create the GitHub release (draft) once. Matrix jobs will `needs` this so the release exists.
  create-release:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - name: Create GitHub release (draft)
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: 'App ${{ github.ref_name }}'
          body: 'See the assets to download this version and install.'
          draft: true
          prerelease: false

  publish-tauri:
    needs: create-release
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            target: 'aarch64-apple-darwin'
          - platform: 'macos-latest'
            target: 'x86_64-apple-darwin'
          - platform: 'ubuntu-22.04'
            target: ''
          - platform: 'windows-latest'
            target: ''
          - platform: 'windows-latest'
            target: 'aarch64-pc-windows-msvc'

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust target (if needed)
        if: matrix.target != ''
        run: |
          echo "Adding Rust target: ${{ matrix.target }}"
          rustup target add ${{ matrix.target }}

      - name: install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf jq

      - name: setup node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'

      - name: ensure Rust toolchain (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: install frontend dependencies
        run: npm install

      - name: Build Tauri app
        run: |
          echo "Building on ${{ matrix.platform }} with target '${{ matrix.target }}'"
          if [ -n "${{ matrix.target }}" ]; then
            npm run tauri build -- --target ${{ matrix.target }}
          else
            npm run tauri build
          fi
        shell: bash

      - name: Find and upload build artifacts to release
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const core = require('@actions/core');

            function walk(dir) {
              let results = [];
              const list = fs.readdirSync(dir || '.');
              list.forEach(function(file) {
                file = path.join(dir, file);
                const stat = fs.statSync(file);
                if (stat && stat.isDirectory()) {
                  results = results.concat(walk(file));
                } else {
                  results.push(file);
                }
              });
              return results;
            }

            const repoRoot = process.cwd();
            const exts = ['.AppImage', '.dmg', '.deb', '.rpm', '.msi', '.exe', '.zip', '.tar.gz', '.tgz', '.pkg'];

            // Search common Tauri bundle locations first, fallback to repo root only if nothing found.
            const searchDirs = [
              path.join('src-tauri','target','release','bundle'),
              path.join('src-tauri','target','release','bundle','osx'),
              path.join('src-tauri','target','release','bundle','debian'),
              path.join('src-tauri','target','release','bundle','linux'),
              path.join('src-tauri','target','release','bundle','msi'),
              path.join('dist'),
              path.join('release')
            ];

            let candidates = [];
            for (const d of searchDirs) {
              const full = path.join(repoRoot, d);
              if (fs.existsSync(full)) {
                candidates = candidates.concat(walk(full));
              }
            }

            // If nothing found in usual places, include repo root (may be large; fallback).
            if (candidates.length === 0) {
              core.info('No artifacts found in expected bundle paths; scanning repo root as fallback (may be slow).');
              candidates = candidates.concat(walk(repoRoot));
            }

            const uniq = Array.from(new Set(candidates));
            const artifacts = uniq.filter(f => {
              const lower = f.toLowerCase();
              for (const e of exts) if (lower.endsWith(e.toLowerCase())) return true;
              try { return fs.statSync(f).size > 1024 && path.basename(f).toLowerCase().includes('refforge'); } catch(e) { return false; }
            });

            if (artifacts.length === 0) {
              core.info('No release artifacts found to upload. Listing candidates for debugging:');
              core.info(JSON.stringify(uniq.slice(0,50), null, 2));
              return;
            }

            const tag = process.env.GITHUB_REF_NAME || (process.env.GITHUB_REF && process.env.GITHUB_REF.replace('refs/tags/','')) || '';
            const release = await github.rest.repos.getReleaseByTag({ owner: context.repo.owner, repo: context.repo.repo, tag });
            const releaseId = release.data.id;

            for (const filePath of artifacts) {
              const name = path.basename(filePath);
              core.info(`Uploading ${filePath} as ${name} to release ${tag}`);
              const data = fs.readFileSync(filePath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: name,
                data: data,
                headers: {
                  'content-type': 'application/octet-stream',
                  'content-length': data.length
                }
              });
            }

  # After all matrix jobs finish, publish the release (clear draft flag)
  publish-release:
    needs: publish-tauri
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    steps:
      - name: Publish GitHub release (clear draft)
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const core = require('@actions/core');
            const tag = process.env.GITHUB_REF_NAME || (process.env.GITHUB_REF && process.env.GITHUB_REF.replace('refs/tags/','')) || '';
            if (!tag) {
              core.setFailed('Tag name not available; cannot publish release.');
              return;
            }
            const release = await github.rest.repos.getReleaseByTag({ owner: context.repo.owner, repo: context.repo.repo, tag });
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              draft: false
            });
            core.info(`Published release for ${tag}`);