name: 'publish'

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'

jobs:
  # Create the GitHub release once. Matrix build jobs will `needs` this job
  # so the release exists before they attempt to upload assets.
  create-release:
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Create GitHub release (draft)
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: 'App ${{ github.ref_name }}'
          body: 'See the assets to download this version and install.'
          draft: true
          prerelease: false

  publish-tauri:
    needs: create-release
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest' # for Arm based macs (M1 and above).
            args: '--target aarch64-apple-darwin'
          - platform: 'macos-latest' # for Intel based macs.
            args: '--target x86_64-apple-darwin'
          - platform: 'ubuntu-22.04'
            args: ''
          - platform: 'windows-latest'
            args: ''
          - platform: 'windows-latest'
            args: '--target aarch64-pc-windows-msvc'

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4
      - name: Rust target for Windows ARM64
        if: matrix.args == '--target aarch64-pc-windows-msvc'
        run: rustup target add aarch64-pc-windows-msvc

      - name: install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04' # This must match the platform value defined above.
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf jq

      - name: setup node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm' # Set this to npm, yarn or pnpm.

      - name: install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: install frontend dependencies
        run: npm install

      - name: Build Tauri app
        run: |
          echo "Building on ${{ matrix.platform }} with args '${{ matrix.args }}'"
          npm run tauri build -- ${{ matrix.args }}

      - name: Find and upload build artifacts to release
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const core = require('@actions/core');

            // Helper: recursively list files under a dir
            function walk(dir) {
              let results = [];
              const list = fs.readdirSync(dir || '.');
              list.forEach(function(file) {
                file = path.join(dir, file);
                const stat = fs.statSync(file);
                if (stat && stat.isDirectory()) {
                  results = results.concat(walk(file));
                } else {
                  results.push(file);
                }
              });
              return results;
            }

            const repoRoot = process.cwd();
            // Candidate extensions for installer artifacts
            const exts = ['.AppImage', '.dmg', '.deb', '.rpm', '.msi', '.exe', '.zip', '.tar.gz', '.tgz', '.pkg'];

            // Search common Tauri bundle locations
            const searchDirs = [
              path.join('src-tauri','target'),
              path.join('src-tauri','target','release','bundle'),
              path.join('src-tauri','target','release','bundle','osx'),
              path.join('src-tauri','target','release','bundle','debian'),
              path.join('src-tauri','target','release','bundle','linux'),
              path.join('src-tauri','target','release','bundle','msi'),
              path.join('dist'),
              path.join('release')
            ];

            let candidates = [];
            for (const d of searchDirs) {
              const full = path.join(repoRoot, d);
              if (fs.existsSync(full)) {
                candidates = candidates.concat(walk(full));
              }
            }

            // Also include any large installers in the workspace root
            candidates = candidates.concat(walk(repoRoot));

            // Filter unique and by extension and reasonable size (>1KB)
            const uniq = Array.from(new Set(candidates));
            const artifacts = uniq.filter(f => {
              const lower = f.toLowerCase();
              for (const e of exts) if (lower.endsWith(e.toLowerCase())) return true;
              try { return fs.statSync(f).size > 1024 && path.basename(f).toLowerCase().includes('refforge'); } catch(e) { return false; }
            });

            if (artifacts.length === 0) {
              core.info('No release artifacts found to upload. Listing candidates for debugging:');
              core.info(JSON.stringify(uniq.slice(0,50), null, 2));
              return;
            }

            // Get the release by tag name
            // GitHub Actions exposes the tag name in GITHUB_REF when triggered by a tag push.
            // Use GITHUB_REF_NAME (newer) or fall back to parsing GITHUB_REF.
            const tag = process.env.GITHUB_REF_NAME || (process.env.GITHUB_REF && process.env.GITHUB_REF.replace('refs/tags/','')) || '';
            const release = await github.rest.repos.getReleaseByTag({ owner: context.repo.owner, repo: context.repo.repo, tag });
            const releaseId = release.data.id;

            for (const filePath of artifacts) {
              const name = path.basename(filePath);
              core.info(`Uploading ${filePath} as ${name} to release ${tag}`);
              const data = fs.readFileSync(filePath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: name,
                data: data,
                headers: {
                  'content-type': 'application/octet-stream',
                  'content-length': data.length
                }
              });
            }
